<font size=4 color=green face="微软雅黑">

# 系统调用

**<font color=blue>系统调用是受控的内核入口. 进程可以请求内核以自己的名义去执行某些动作. 以应用程序编程接口的形式, 内核提供有一系列服务程序访问. 包括创建新进程, 执行I/O, 以及为进程间通信创建管道等.</font>**

## 关注点

1. 系统调用将处理器从用户态切换到和心态, 以便CPU访问收到保护的内核内存.
2. 系统调用的组成是固定的, 每个系统调用都由一个唯一的数字来标识.
3. 每个系统调用可辅之以一套参数, 对应胡空间与内核空间之间传递的信息加以规范.



## 系统调用时内核的动作

**<font color=blue>从编程角度看, 系统调用与C语言函数的调用很相似. 但是在执行系统调用时, 其幕后会经历诸多步骤：</font>**

1. **<font color=blue>应用程序用过调用C语言函数库中的外壳(wrapper)函数没来发起系统调用.</font>**
2. **<font color=blue>外壳函数:</font>**
	+ 参数合法性验证: 对系统调用终端处理例程来说,外壳函数必须保证所有的系统调用参数可用. 
	+ 参数存入寄存器: 通过堆栈, 这些参数传入外壳函数, 但内核却希望将这些参数置入特定寄存器. 因此, 外壳函数会将上述参数复制到寄存器.
	+ 添加系统调用编号: 由于所有系统调用进入内核的方式相同, 内核需要设法区分每个系统调用. 为此, 外壳函数会将系统调用编号复制到一个特殊的CPU寄存器(%eax) 中.
	+ 切换状态: 外壳函数执行一条中断机器指令,引发处理器从用户态切换到核心态,并执行系统中断(0x80 十进制数128)的中断矢量所执行的代码(sysenter指令进入内核的速度更快. 2.6内核及glibc2.3.2以后的版本都支持sysenter指令).
3. **<font color=blue>内核调用system_call()例程处理响应中断:</font>**
	+ 在内核栈中保存寄存器的值.
	+ 审核系统调用编号的有效性.
	+ 以系统调用编号对存放所有调用服务里程的列表(内核变量sys_call_table)进行索引, 发现并调用相应的系统调用服务例程. 若系统调用带有参数, 那么将首先检查参数有效性. 随后该服务李成会执行必要的任务, 涉及对特定参数中指定地址处的值进行修改, 在用户内存和内核内存键传递数据等, 最后, 该服务例程会将结果状态返回给system_call()例程.
	+ 从内核栈中恢复各寄存器的值, 并将系统调用返回值置于栈中.
	+ 返回至外壳函数, 同时将处理器切换回用户态. 
4. **<font color=blue>返回值处理:</font>**
	+ 若西永调用服务李成飞的返回值标明调用有误, 外壳函数会使用改制来设置全局变量errno. 然后,外核函数会返回到调用程序, 并同时返回一个整形值, 以表明系统调用是否成功.
	+ 系统调用服务例程遵循的管理是调用成功则返回非负值.
	+ 发生错误时,例程会对相应errno常量取反, 返回一负值. C语言函数库的外壳函数随即对其再次取反, 将结果拷贝至errno, 同时以 -1 作为外壳函数的返回值返回, 向调用程序标明有错误发生.
	+ 调用成功则不会返回负值.会出现特殊情况, 系统杜奥用fcntl()的F_GETOWN操作, 取反的errno值范围会与调用成功返回负值的范围有交集.
5. **<font color=blue>系统调用的开销虽小, 却也不容忽视</font>**
	+ 从C语言编程的角度看, 调用C语言函数库的外壳函数等同于调用相应的系统调用服务例程.
	+ 但是 系统调用会比单纯的调用C语言函数库函数开销大.

