<font size=4 color=#D8650D face="微软雅黑">

# 原子操作和竞争条件

## 原子操作:

+ 内核保证了某个系统调用中的所有步骤会作为独立操作而一次性加以执行, 期间不会为其他进程或线程所终端
+ 原子性是某些操作得意圆满成功的关键所在, 他规避了竞争状态

## 竞争状态:

+ 操作共享资源的两个进程(或线程), 其结果取决于一个无法预期的顺序, 即这些进程获得CPU使用权的先后相对顺序


## 以独占方式创建一个文件

+ 要保证进程是打开文件的创建者, 在调用open()是指定O_EXCL和O_CREAT, 如果打开的文件已存在, 则open()返回错误.
+ 错误代码:

```c
fd = open(argv[1], O_WRONLY);

if(fd != -1)
{
	printf("[PID %ld] File \"%s\" already exists\n", (long)getpid(), argv[1]);
	close(fd);
}
else
{
	if(errno != ENOENT)
	{
		errExit("open");
	}
	else
	{
		fd = open(argv[1], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);
		if(fd == -1)
		{
			errExit("open");
			printf("[PID %ld] Created file \"%s\" exclusively\n", (long)getpid(), argv[1]);
		}
	}
}
```
以上代码除了要调用open()两次外, 还有一个bug
当第一次调用open()时, 希望打开的文件尚不存在, 而当第二次调用open()时, 其他进程已经创建了该文件
若内核调度器判断出分配给A进程的时间片已经耗尽, 并将CPU使用权交给了B进程, 就可能会发生这种问题.
另外, 两个进程在一个多CPU系统上同时运行时, 也会出现这种情况
这时, 进程A讲得出错误的结论, 目标文件是自己创建的, 因为无论目标文件存在与否, 进程Ａ对open()的第二次调用都会成功

上述情况下, 这段代码属于不可靠代码, 操作结果将依赖与对两个进程的调度顺序, 这就意味着出现了竞争状态

由于进程A在检查文件是否存在和创建文件之间发生了中断, 造成两个进程都生成自己是文件的创建者

结合 O_CREAT和O_EXCL 标识来一次性的调用open()可以防止这种情况, 确保了检查文件和创建文件的步骤属于一个单一的原子操作.

## 向文件尾部追加数据

+ 多个进程同时向同一个文件尾部添加数据时:

```c
if(lseek(fd, 0, SEEK_END) == -1)
	errExit("lseek");
if(write(fd, buf, len) != len)
	fatal("Partial/failed write");
```

+ 这段代码的缺陷和上一段几乎一样
+ 当进程A执行到lseek()和write()之间, 被执行相同代码的进程B所中断, 那么这两个进程会在写入数据前, 将文件偏移量设为相同位置, 二当进程A再次获得调度时, 会覆盖进程B已写入的数据, 此时又出现了竞争状态, 因为执行结果依赖于内核对两个进程的调度顺序
+ 同样, 在打开文件时加入O_APPEND标识, 就可以保证将文件偏移量的移动与数据写操作纳入同一原子操作