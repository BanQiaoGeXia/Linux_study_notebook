<font size=4 color=#D8650D face="微软雅黑">

# /dev/fd 目录

+ 对于每个进程, 内核都提供有一个特殊的虚拟目录/dev/fd. 
+ 该目录包含"/dev/fd/n"形式的文件名, 其中n是与进程中的打开文件描述符相对应的编号
+ 如: /dev/fd/0 就对应于进程的标准输入
+ 打开/dev/fd目录中的一个文件等同于赋值相应的文件描述符:
	+ fd = open("/dev/fd/1", O_WRONLY);
	+ fd = dup(1);
	+ 这两行代码是等价的
+ 在为open()调用设置flag参数时, 需要注意将其设置为与原描述符相同的访问模式, 因为在这一场景下, 在flag标志的设置中引入其他标识是毫无意义的, 系统会将其忽略

**/dev/fd实际上是一个符号链接, 链接到Linux所专有的/proc/self/fd目录. 后者又是Linux特有的/proc/PID/fd目录族的特例之一, 此目录族中的每一目录都包含有符号链接, 予以进程锁打开的所有文件相对应**

+ 程序中很少使用/dev/fd目录中的文件, 其主要用途在shell中.
+ 许多用户级shell命令将文件名作为参数, 又是需要将命令输出至管道, 并将某个参数替换为标准输入或标准输出. 
+ 处于这一目的, 某些命令(diff, ed, tar, comm)提供了使用"-"符号作为命令的参数的方法, 用以表示标准输入或输出
+ 所以, 要比较ls命令输出的文件名列表与之前声称的文件名列表, 命令就可以写成:
		$ ls | diff - oldfilelist

+ 这种方法存在问题
+ 该方法要求每个程序都对"-"符号做专门处理, 但是许多程序并未实现这样的功能, 这些命令只能处理文件, 不支持将标准输入或输出作为参数, 有些程序还将单个"-"符解释为表征命令行选项结束的分隔符.

+ 使用/dev/fd目录, 上述问题就不存在了, 可以把标准输入, 标准输出和标准错误作为文件名参数传递给任何需要它们的程序, shell命令改写成如下形式:
		$ ls | diff /dev/fd/0 oldfilelist

+ 系统还提供了三个符号链接: /dev/stdin, /dev/stdout, /dev/stderr, 分别连接到/dev/fd/0, /dev/fd/1, /dev/fd/2.