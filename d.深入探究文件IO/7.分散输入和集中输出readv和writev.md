<font size=4 color=#D8650D face="微软雅黑">

# 分散输入和集中输出
# readv()和writev()

**readv()和writev()分别实现了分散输入和集中输出功能**

```c
#include <sys/uio.h>

ssize_t readv(int fd, const struct iovec *iov, int iovcnt);

Returns number of bytes read, 0 on EOF, or -1 on error

ssize_t writev(int fd, const struct iovec *iov, int iovcnt);

Returns number of bytes written, or -1 on error

```

+ 这些调用支持一次传输多个缓冲区的数据, 数组iov定义了一组用来传输数据的缓冲区
+ 整型数iovcnt则指定了iov的成员个数, iov中的每个成员都是如下形式的数据结构:
		struct iovec {
			void *iov_base;
			size_t iov_len;
		};

+ SUSv3标准允许系统实现对iov中的成员个数加以限制, 可以通过定义<limits.h>文件中IOV_MAX来通告这一限额
+ 程序也可以在运行时调用sysconf来获取这一限额
+ SUSv3要求该限额不得小于16, linux将IOV_MAX定义为1024, 这是与内核对该向量大小的限制相对应的
+ 若系统调用因iovcnt参数值过大而失败, 外壳函数将临时分配一块缓冲区, 其大小足够容纳iov参数所有成员所描述的数据缓冲区, 随后在执行read()或write()调用

### 关于iov, iovcnt, 以及iov指向缓冲区之间关系的实例图:

![iovec数组及其相关缓冲区示例图]("/images/p2.png")


##分散输入

+ 从文件描述符fd所指代的文件中读取一片连续的字节, 然后将其散置于iov指定的缓冲区中, 这一动作从iov[0]开始, 依次填满每个缓冲区
+ 原子性是readv()的重要属性, 从调用进程的角度来看, 当调用readv()时, 内核在fd所指代的文件与用户内存之间一次性地完成了数据转移
+ 假设及时有另一进程与其共享同一文件偏移量, 且在调用readv()的同时企图修改文件偏移量, readv()所读取的数据仍将是连续的.
+ 调用readv()成功将返回读取的字节数, 若文件结束将返回0, 调用者必须对返回值进行检查, 已验证读取的字节数是否满足要求, 若数据不足以填充所有缓冲区, 则只会占用部分缓冲区, 其中最后一个缓冲区可能只存有部分数据

**使用readv()执行分散输入**

```c

```

---

## 集中输出