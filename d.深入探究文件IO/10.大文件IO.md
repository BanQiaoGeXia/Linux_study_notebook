<font size=4 color=#D8650D face="微软雅黑">

# 大文件 I/O

---

## 概述

+ 通常将存放文件偏移量的数据类型off_t实现为一个有符号的长整形, 以-1表示错误, 在32位体系结构中, 这将文件大小至于2GB的限制之下
+ 大文件I/O 功能 即传说中的LFS(Large File Summit)功能
+ 应用程序可使用一下两种方式之一获得LFS功能
	+ 使用支持大文件操作的备选API, 该API有LFS设计, 意在作为SUS规范的"过渡型扩展"
	+ 因此, 尽管大部分系统都支持这一API, 但这对于符合SUSv2或SUSv3规范的系统其实并非必须, 这一方法现已过时
	+ 在编译应用程序是, 将宏_FILE_OFFSET_BITS的值定义为64, 这一方法更为可取, 因为符合SUS规范的应用程序无需修改任何源码即可获得LFS功能

## 过渡型 LFS API

+ 要使用过渡型的LFS API, 必须在编译程序时指定_LARGEFULE64_SOURCE功能测试宏, 该定义可以通过命令行指定, 也可以定义与源文件中包含所有头文件之前的位置
+ 该API所属函数具有处理64位文件大小和文件偏移量的能力, 这些函数与其32位版本命名相同, 只是尾部缀以64以示区分
+ 包括 fopen64(), open64(), lseek64(), truncate64(), stat64(), mmap64(),和setrlimit64()
+ 要访问大文件, 可以使用这些函数的64位版本:
	```c
	fd = open64(name, O_CRAT | O_RDWR, mode);
	if(fd == -1)
		errExit("open");
	```
	+ 调用open64(), 相当于在调用open()时指定O_LARGEFILE标志, 若调用open()时未指定此标志, 且欲打开的文件大小大于2GB, 那么调用将返回错误

+ 除去上面提及的函数之外, 过渡型LFS API还增加了一些新的数据类型
	+ struct stat64: 类似于stat结构, 支持大文件尺寸
	+ off64_t: 64位类型, 用于表示文件偏移量



## _FILE_OFFSET_BITS宏

## 向 printf() 调用传递 off_t 值
