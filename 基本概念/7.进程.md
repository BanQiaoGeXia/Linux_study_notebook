<font size=4 color=green face="微软雅黑">
# 进程

***

**进程是正在执行的程序实例**

**内核会将程序代码载入虚拟内存,为程序分配空间,建立内核记账(bookkeeping)数据结构**

** 在内核看来,进程是一个个尸体,内核必须在他们之间共享各种计算机资源**

## 进程的内存布局

**程序将一个进程划分为以下几个部分(也成为 段 ):**
	
	文本: 程序的指令(代码区)
	数据: 程序使用的静态变量(常量区)
	堆:   程序课从给须臾动态分配额外内存(堆区)
	栈:   随函数调用-返回而增减的一片内存,永远为局部比阿娘和函数调用链接信息分配存储空间(栈区)

**这就是传说中的内存四区**

**每一个进程都有属于自己的独立的内存四区**	

## 创建进程和执行程序

系统调用fork()可以创建新进程.

调用fork()的进程被称为父进程,新创建的进程被称为子进程

内核通过对父进程的复制来创建子进程

子进程从父进程出继承数据段,栈段以及堆段的副本后,可以修改这些内容,不会影响父进程的"原版"内容

***(在进程中被标记为只读的程序文本段则由父.子进程共享)***

子进程可以执行与父进程共享代码段中的另一组不同函数, 更为常见的情况是使用系统调用execve()去加载并执行一个全新程序
	
	execve()会销毁现有的文本段,数据段,栈段以及堆段,并根据新程序的代码,创建新段来替换它们
	
	以execve()为基础
	
	C语言库函数还提供了几个相关函数,函数名称以"exec"打头

## 进程ID 和父进程ID

**每一进程都有一个唯一的整事行进程标志符(PID)**

**此外,每一进城还具有一个父进程标识符(PPID)属性, 用以标志请求内核创建自己的进程** 

## 进程终止和终止状态

### 终止一个进程
	
	1.进程可使用_exit()系统调用(或相关的exit()库函数), 请求退出
	2.向进程传递信号,将其杀死

无论以何种方式退出,进程都会生成"终止状态", 一个非负小整数, 可供父进程的wait()系统调用检测.

在调用_exit()的情况下,进程会指明自己的终止状态

若由信号来"杀死"进程,则会根据导致进程"死亡"的信号类型来设置进程的终止状态

根据惯例, 终止状态为0 表示进程正常推出, 非0的表示有错误发生.大多数shell会将前一执行程序的终止状态保存于射而来变量$?中.

## 进程的用户和组标识符(凭证)

**每个进程都摇头伊苏与之相关的用户ID(UID) 和组ID(GID) 
	
### 真实用户ID 和组ID

	用来标识进程所属的用户和组.新进程从其父进程处继承这些ID.登陆shell则会从系统密码文件的响应字段中获取器真实用户ID和组ID

### 有效用户ID 和组ID
	
	进程在访问收保护资源(比如: 文件和进程间通信对象)时, 会使用这两个ID来确定访问权限,一般情况下,进程的有效ID与响应的真实ID值相同.

<font color=red size=3>改变进程的有效ID实为一种机制,可是进程具有其他用户或组的权限</font>

### 补充组ID
	
	用来标识进程所属的额外组.新进程从其父进程处继承补充组ID.
	登陆shell则从系统组文件中获取其补充组ID

## 特权进程

----


## 能力

----

## init进程

---

## 守护进程

---

## 环境列表

---

## 资源限制

---
