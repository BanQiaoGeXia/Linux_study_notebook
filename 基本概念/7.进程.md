<font size=4 color=green face="微软雅黑">
# 进程

***

**进程是正在执行的程序实例**

**内核会将程序代码载入虚拟内存,为程序分配空间,建立内核记账(bookkeeping)数据结构**

** 在内核看来,进程是一个个尸体,内核必须在他们之间共享各种计算机资源**

## 进程的内存布局

**程序将一个进程划分为以下几个部分(也成为 段 ):**
	
	文本: 程序的指令(代码区)
	数据: 程序使用的静态变量(常量区)
	堆:   程序课从给须臾动态分配额外内存(堆区)
	栈:   随函数调用-返回而增减的一片内存,永远为局部比阿娘和函数调用链接信息分配存储空间(栈区)

**这就是传说中的内存四区**

**每一个进程都有属于自己的独立的内存四区**	

## 创建进程和执行程序

系统调用fork()可以创建新进程.

调用fork()的进程被称为父进程,新创建的进程被称为子进程

内核通过对父进程的复制来创建子进程

子进程从父进程出继承数据段,栈段以及堆段的副本后,可以修改这些内容,不会影响父进程的"原版"内容

***(在进程中被标记为只读的程序文本段则由父.子进程共享)***

子进程可以执行与父进程共享代码段中的另一组不同函数, 更为常见的情况是使用系统调用execve()去加载并执行一个全新程序
	
	execve()会销毁现有的文本段,数据段,栈段以及堆段,并根据新程序的代码,创建新段来替换它们
	
	以execve()为基础
	
	C语言库函数还提供了几个相关函数,函数名称以"exec"打头

## 进程ID 和父进程ID

**每一进程都有一个唯一的整事行进程标志符(PID)**

**此外,每一进城还具有一个父进程标识符(PPID)属性, 用以标志请求内核创建自己的进程** 

## 进程终止和终止状态

### 终止一个进程
	
	1.进程可使用_exit()系统调用(或相关的exit()库函数), 请求退出
	2.向进程传递信号,将其杀死

无论以何种方式退出,进程都会生成"终止状态", 一个非负小整数, 可供父进程的wait()系统调用检测.

在调用_exit()的情况下,进程会指明自己的终止状态

若由信号来"杀死"进程,则会根据导致进程"死亡"的信号类型来设置进程的终止状态

根据惯例, 终止状态为0 表示进程正常推出, 非0的表示有错误发生.大多数shell会将前一执行程序的终止状态保存于射而来变量$?中.

## 进程的用户和组标识符(凭证)

**每个进程都摇头伊苏与之相关的用户ID(UID) 和组ID(GID) 
	
### 真实用户ID 和组ID

	用来标识进程所属的用户和组.新进程从其父进程处继承这些ID.登陆shell则会从系统密码文件的响应字段中获取器真实用户ID和组ID

### 有效用户ID 和组ID
	
	进程在访问收保护资源(比如: 文件和进程间通信对象)时, 会使用这两个ID来确定访问权限,一般情况下,进程的有效ID与响应的真实ID值相同.

<font color=red size=3>改变进程的有效ID实为一种机制,可使进程具有其他用户或组的权限</font>

### 补充组ID
	
	用来标识进程所属的额外组.新进程从其父进程处继承补充组ID.
	登陆shell则从系统组文件中获取其补充组ID

## 特权进程

**特权进程:** 

1.有效用户ID为0的进程, 通常由内核所施加的权限限制对此类进程无效

2.由某一特权进程创建的进程,也可以是特权进程.

3.利用set-user-ID机制,允许某进程的有效用户ID等用于该进程所执行程序文件的用户ID

**无特权:** 

由其他用户运行的进程,有效用户ID为非0,且必须遵守有内核所强加的权限规则

## 能力

1.每次特选操作都与特定的能力相关

2.仅当进程具有特定能力时,才能执行响应操作

3.传统意义上的超级用户进程(有效用户ID为0)则相应解锁了所有能力

## init进程

**所有进程之父**

**程序文件:** /sbin/init

1.系统的所有进程不是由init亲自fork()创建,就是由其后代创建的

2.init进程的进程号总为1,切总是以超级用户权限运行,任何用户都不能杀死init进程,除非关闭系统

3.init的主要任务是创建并监控系统运行所需的一系列进程

## 守护进程

**指具有特殊用途的进程,系统创建和处理此类进程的方式与其他进程*****<font size=5 color=red>相同</font>***

1.守护进程通常在系统引导时启动,直至系统关闭前,会一直健在

2.守护进程在后台运行,且无控制终端供其读取或写入数据

**例如:** 

syslog---在系统日志中记录消息

httpd----利用HTTP协议分发Web页面


## 环境列表

**每个进程都有一份环境列表,记载进程用户控件内存中维护的一组环境变量**
	
	这份列表的每一元素都由一个名称及其相关值组成.
	由fork()创建的新进程,会继承父进程的环境副本.这也为父子进程间通信提供了一种机制.
	当进程调用exec()替换当前正在运行的程序时,新程序要么继承老程序的环境,要么在exec()调用的参数中指定新环境并加以接收

**在绝大多数shell中,可使用export命令来创建环境变量**
	
	export MYVAR='hello'

**C语言程序可使用外部变量(插入 \*\*environ)来访问环境,儿库函数也允许进程去获取或修改自己环境中的值**

**用途:**

	shell定义并使用了一系列变量,供shell执行的脚本和程序访问:
	包括:
		变量HOME(明确定义了用户登陆目录的路径名)
		变量PATH(指明了用户输入命令后,shell查找与之相应程序是所搜索的目录列表)
	
## 资源限制

**每个in成都会消耗诸如打开文件,内存以及CPU时间之类的资源**

**使用系统调用setrlimit(),进程可以为自己消耗的各类资源设定一个上限**

**此类资源限制的每一项均有两个相关值:**
	
	软限制:
		限制了进程可以消耗的资源总量
	硬限制:
		软限制的调整上限
	
**非特权进程在针对特定资源调整软限制时,可将其设置为0到响应硬限制值之间的任意值,
但硬限制值则只能调低,不能调高**


**<font color=blue>由fork()创建的新进程,会继承其父进程对资源限制的设置</font>**

**<font color=red>使用ulimit命令(C shell 中为limit)可调整shell的资源限制.shell未执行命令所创建的子进程会继承上相互资源设置</font>**