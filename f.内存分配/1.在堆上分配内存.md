<font size=4 color=#264246 face="微软雅黑">

# 在堆上分配内存
---
**进程可以通过增加堆的大小来分配内存**

## 堆
+ 是一段长度可变的连续细腻内存, 始于进程的未初始化数据段末尾, 随着内存的分配和释放而增减
+ 通常将对的当前内存边界称为 "program break"

## 调整program break : brk()和sbrk()

+ 改变堆的大小(即分配或释放内存), 最初, program break的位置位于未初始化数据段末尾, 如图:
![](images/1.png)

+ 在program break的位置抬升后, 程序可以访问新分配区域内的任何内存地址, 而此时屋里内存页还没有分配
+ 内核会在进程首次试图访问这些虚拟内存地址时自动分配新的物理内存页
+ 两个操作program break的系统调用: brk()和sbrk():

```c
#include <unistd.h>

int brk(void * end_data_segment);

	Returns 0 on success, or -1 on error

void *sbrk(intptr_t increment);

	Returns previous program break on success, or (void *)-1 on error

```

+ 系统调用brk()会将program break设置为参数end_data_segment所指定的位置, 由于内存页页为单位进行内存分配, end_data_segment实际会四舍五入到下个内存页的边界处
+ 当试图将program break设置为一个低于其初始值得位置时, 可能会导致无法预知的行为, 例如:
	+ 当程序试图访问的数据位于初始化或未初始化数据段中当前尚不存在的部分时, 就会引发段内存访问错误(segentation fault)
+ program break可以设定的精确上限取决于一些因素, 包括进程中对数据段大小的资源限制, 以及内存映射, 共享内存段, 共享库的位置等
+ 调用sbrk()将program break在原有地址上增加从参数increment出入的大小, 用于声明increment的intptr_t类型属于整数数据类型
+ 调用成功, sbrk()返回前一个program break的地址, 即如果program break增加, 那么返回值是指向这块新分配内存起始位置的指针
+ 调用sbrk(0)将返回program break的当前位置, 对其不做改变, 再意图跟踪堆的大小, 或是见识内存分配函数包的行为时, 会用到这一用法

## 在堆上分配内存: malloc()和free()

+ C程序使用malloc函数族在堆上分配和释放缓存, 脚趾brk()和sbrk(), 这些函数具备如下优点:
	+ 属于C语言标准的一部分
	+ 更易于在多线程程序中使用
	+ 接口简单, 允许分配小块内存
	+ 允许随意释放内存块, 它们被维护与一张空闲内存列表中, 在后续内存分配调用时循环使用
+ malloc()函数在堆上分配size字节大小的内存, 并返回指向新分配内存其实位置处的指针, 其所分配的内存未经初始化

```c
#include <stdlib.h>

void *malloc(size_t size);

	Returns pointer to allocated memory on success, or NULL on error
```
+ 由于malloc()的返回类型为void*, 因而可以将其赋给任意类型的C指针
+ malloc()返回内存块所采用的字节对齐方式, 总是适宜于高效访问任何类型的C语言数据结构
+ 在大多数硬件架构上, 这实际意味着malloc()是基于8字节或16字节边界来分配内存的
+ 若无法分配内存, 则malloc()返回NULL, 并设置errno以返回错误信息, 虽然分配内存失败的可能性很小, 但所有对malloc以及后续体积的相关函数的调用都应对返回值进行错误检查
+ free()函数释放ptr参数所指向的内存块, 该参数应该是之前由malloc(), 或者其他堆内存分配函数之一所返回的地址

```c
#include <stdlib.h>

void free(void* ptr);
```
+ 一般情况下, free()并不降低program break的位置, 而是讲这块内存添加到空闲内存列表中, 共后续的malloc()函数循环使用, 这么做的原因是:
	+ 被释放的内存块通常会位于堆的中间, 而非堆的顶部, 因为江都program break是不可能的
	+ 它最大限度地减少了程序必须执行的sbrk()调用次数
	+ 在大多数情况下, 降低program break的位置不会对那些分配大量内存的程序有多少帮助, 因为它们同城倾向于持有已分配内存或是反复释放和重新分配内存, 而非释放所有内存后再持续运行一段时间
+ 如果传给free()的是一个空指针, 那么函数将什么都不做
+ 在调用free()后对参数ptr的任何使用, 例如将其再次传递给free(), 将产生错误, 并可能导致不可预知的结果

## 程序示例



## malloc()和free()的实现

## 在堆上分配内存的其他方法