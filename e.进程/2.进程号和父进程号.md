<font size=4 color=#4B2296 face="微软雅黑">

# 进程号和父进程号


+ 每个进程都有一个进程号(PID), 进程号是一个正数, 用以唯一标识系统中的某个进程.
+ 对系统调用而言, 进程号有时可以作为传入参数, 有时可以作为返回值
+ 系统调用getpid()返回调用进程的进程号:

```c
#include <unitd.h>

pid_t getpid(void);

Always successfully returns process ID caller
```

+ getpid()返回值pid_t类型是SUSv3所规定的整数类型, 专用于存储进程号
+ 除少数系统进程外(如init进程, 进程号为1), 程序与运行该程序的进程的进程号之间没有固定关系.
+ Linux内核限制进程号需小于等于32767(16位有符号整形最大值), 新进程创建是, 内核会按顺序将下一个可用进程号分配给其使用.
+ 每当进程号达到32767的限制时, 内核将重置进程计数器, 以便从小整数开始分配
+ 一旦进程号达到32767, 会将进程号计数器重置为300, 而不是1, 因为低数值的进程号为系统进程的守护进程所长期占用
+ 尽管进程号的默认上限为32767, 但可以通过Linux系统特有的 `/proc/sys/kernel/pid_max`文件来进行调整, 在32位平台中, pid_max文件的最大职位32768, 但是在64位平台中, 该文件的最大值可以高达 2^22(约400万), 系统可能容纳的进程数量会非常庞大
+ 每个进程都有一个创建自己的父进程, 使用系统调用getppid()可以检索到父进程的进程号.

```c
#include <unistd.h>

pid_t getppid(void);

Always successfully returns process ID of parent of caller
```

+ 每个进程的父进程号属性反应了系统上所有进程间的树状关系, 每个进程的父进程又有自己的父进程, 回溯到1号进程--init进程, 即所有进程的始祖
+ 使用pstree(1)命令可以查看到这一"家族树"
+ 如果子进程的父进程终止, 则子进程就会变成"孤儿", init进程随即将收养该进程, 子进程后续对getppid()的调用将返回进程号1
+ 通过查看由Linux系统所特有的 `proc/PID/status` 文件所提供的PPid字段, 可以获知每个进程的父进程